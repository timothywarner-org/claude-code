# Exercise 2: Analyze and Optimize API Costs

## Learning Objectives

By the end of this exercise, you will be able to:

1. Calculate token usage for Claude API calls
2. Implement cost tracking and budgeting
3. Optimize prompts to reduce token consumption
4. Create alerts for cost anomalies
5. Build dashboards for cost visibility

## Prerequisites

- Understanding of Claude's pricing model
- Basic TypeScript/JavaScript skills
- Access to API usage logs
- Familiarity with token counting concepts

## Background

Claude API costs are based on token usage:

- Input tokens: Text sent to Claude
- Output tokens: Text generated by Claude

Pricing varies by model:

| Model             | Input (per 1M tokens) | Output (per 1M tokens) |
| ----------------- | --------------------- | ---------------------- |
| Claude 3.5 Sonnet | $3.00                 | $15.00                 |
| Claude 3 Opus     | $15.00                | $75.00                 |
| Claude 3 Haiku    | $0.25                 | $1.25                  |

Effective cost management requires understanding usage patterns and optimization strategies.

## Step-by-Step Instructions

### Step 1: Implement Token Counting

Create a token counter using the `@anthropic-ai/tokenizer` package:

```typescript
import { countTokens } from '@anthropic-ai/tokenizer';

function estimateTokens(text: string): number {
  return countTokens(text);
}
```

### Step 2: Build a Cost Calculator

Open `exercise_2_cost_calculator.ts` and implement:

1. Token counting for input/output
2. Cost calculation per model
3. Running total tracking
4. Budget limit enforcement

### Step 3: Create Usage Tracker

Implement usage logging:

```typescript
interface UsageRecord {
  timestamp: Date;
  model: string;
  inputTokens: number;
  outputTokens: number;
  cost: number;
  purpose: string;
}

class UsageTracker {
  private records: UsageRecord[] = [];

  log(record: UsageRecord): void {
    this.records.push(record);
    this.checkBudget();
  }

  getDailyUsage(): number {
    // Calculate today's total
  }

  getMonthlyUsage(): number {
    // Calculate this month's total
  }
}
```

### Step 4: Implement Budget Alerts

Create alert thresholds:

```typescript
interface BudgetConfig {
  dailyLimit: number;
  monthlyLimit: number;
  alertThresholds: number[]; // e.g., [0.5, 0.75, 0.9]
  alertCallback: (message: string) => void;
}

function checkBudgetAlerts(usage: number, limit: number, config: BudgetConfig): void {
  const percentage = usage / limit;

  for (const threshold of config.alertThresholds) {
    if (percentage >= threshold) {
      config.alertCallback(`Budget alert: ${(percentage * 100).toFixed(1)}% of ${limit} used`);
    }
  }
}
```

### Step 5: Optimize Prompt Engineering

Implement prompt optimization strategies:

**Strategy 1: Context Compression**

```typescript
function compressContext(text: string, maxTokens: number): string {
  const tokens = estimateTokens(text);

  if (tokens <= maxTokens) return text;

  // Summarize or truncate
  const ratio = maxTokens / tokens;
  return text.slice(0, Math.floor(text.length * ratio * 0.9));
}
```

**Strategy 2: Caching**

```typescript
const responseCache = new Map<string, { response: string; expires: number }>();

function getCachedResponse(prompt: string): string | null {
  const hash = hashPrompt(prompt);
  const cached = responseCache.get(hash);

  if (cached && cached.expires > Date.now()) {
    return cached.response;
  }

  return null;
}
```

**Strategy 3: Model Selection**

```typescript
function selectOptimalModel(task: string, inputTokens: number): string {
  // Simple tasks: Use Haiku
  if (task === 'classification' || task === 'extraction') {
    return 'claude-3-haiku-20240307';
  }

  // Complex tasks with large context: Use Sonnet
  if (inputTokens > 50000) {
    return 'claude-3-5-sonnet-20241022';
  }

  // Default to Sonnet for quality
  return 'claude-3-5-sonnet-20241022';
}
```

### Step 6: Build Cost Dashboard

Create a dashboard showing:

- Daily/weekly/monthly costs
- Cost by purpose/feature
- Token efficiency metrics
- Budget remaining
- Trend analysis

### Step 7: Implement Cost Hooks

Add middleware for automatic tracking:

```typescript
function withCostTracking<T>(
  fn: () => Promise<{ response: T; usage: { input_tokens: number; output_tokens: number } }>,
  purpose: string
): Promise<T> {
  const start = Date.now();

  return fn().then((result) => {
    const cost = calculateCost('claude-3-5-sonnet-20241022', result.usage.input_tokens, result.usage.output_tokens);

    tracker.log({
      timestamp: new Date(),
      model: 'claude-3-5-sonnet-20241022',
      inputTokens: result.usage.input_tokens,
      outputTokens: result.usage.output_tokens,
      cost,
      purpose,
    });

    return result.response;
  });
}
```

### Step 8: Set Up Reporting

Create automated reports:

```typescript
interface CostReport {
  period: 'daily' | 'weekly' | 'monthly';
  totalCost: number;
  totalInputTokens: number;
  totalOutputTokens: number;
  byPurpose: Record<string, number>;
  topCostDrivers: Array<{ purpose: string; cost: number }>;
  recommendations: string[];
}

function generateReport(period: 'daily' | 'weekly' | 'monthly'): CostReport {
  // Implementation
}
```

## Expected Outcomes

After completing this exercise:

1. Accurate token counting for all requests
2. Real-time cost tracking
3. Budget alerts working correctly
4. Cost-optimized prompt templates
5. Comprehensive cost dashboard

## Verification Checklist

- [ ] Token counter matches API usage reports
- [ ] Cost calculations are accurate
- [ ] Budget alerts trigger at correct thresholds
- [ ] Caching reduces duplicate requests
- [ ] Model selection optimizes cost/quality
- [ ] Dashboard shows accurate metrics

## Bonus Challenges

### Challenge 1: Predictive Budgeting

Build a model to predict monthly costs based on usage patterns:

- Analyze historical usage
- Detect trends and seasonality
- Forecast end-of-month spend
- Alert on trajectory issues

### Challenge 2: Cost Allocation

Implement cost allocation by team/project:

- Tag requests with metadata
- Aggregate costs by dimension
- Generate team-specific reports
- Enable chargebacks

### Challenge 3: A/B Testing for Prompts

Test prompt variants for cost efficiency:

- Track metrics per prompt version
- Calculate cost/quality ratio
- Automate winner selection

### Challenge 4: Smart Rate Limiting

Implement intelligent rate limiting:

- Per-user limits
- Priority queuing
- Graceful degradation
- Fair scheduling

## Cost Optimization Strategies

### Input Token Reduction

1. **Remove unnecessary context** - Only include relevant information
2. **Use references** - "As mentioned above" instead of repeating
3. **Compress examples** - Use minimal but representative examples
4. **Structured formats** - JSON/XML instead of verbose prose

### Output Token Reduction

1. **Specify length** - "Respond in 2-3 sentences"
2. **Request format** - "Return only the JSON, no explanation"
3. **Use stop sequences** - Prevent rambling
4. **Single-turn when possible** - Avoid multi-turn for simple tasks

### Architectural Optimization

1. **Batch similar requests** - Combine related queries
2. **Cache aggressively** - Store responses for reuse
3. **Use streaming** - Cancel early if answer is found
4. **Implement fallbacks** - Try Haiku before Opus

## Common Issues and Solutions

### Issue: Token count mismatch with API

The tokenizer estimates may differ slightly from actual API counts:

```typescript
// Add 5% buffer for safety
const estimatedCost = calculateCost(tokens) * 1.05;
```

### Issue: Budget exceeded before alert

Implement pre-request budget checking:

```typescript
async function safeApiCall(prompt: string): Promise<string> {
  const estimatedInput = estimateTokens(prompt);
  const estimatedCost = calculateCost(estimatedInput, estimatedInput * 2);

  if (tracker.wouldExceedBudget(estimatedCost)) {
    throw new BudgetExceededError('Request would exceed budget');
  }

  return apiCall(prompt);
}
```

### Issue: Costs spike unexpectedly

Implement circuit breaker pattern:

```typescript
class CostCircuitBreaker {
  private failures = 0;
  private lastCheck = Date.now();

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.isOpen()) {
      throw new Error('Circuit breaker open due to cost spike');
    }

    try {
      return await fn();
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }
}
```

## Resources

- [Anthropic Pricing](https://www.anthropic.com/pricing)
- [Token Counting Guide](https://docs.anthropic.com/claude/docs/tokens)
- [API Usage Dashboard](https://console.anthropic.com/usage)
